const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');

class MinigamesSystem {
    constructor(economySystem) {
        this.economy = economySystem;
        this.activeGames = new Map(); // Para manejar juegos en progreso
        
        // Configuraci√≥n de minijuegos
        this.config = {
            coinflip: {
                minBet: 50,
                maxBet: 10000,
                cooldown: 15000, // 15 segundos entre juegos
                winMultiplier: 1.95 // Ganas 95% adicional (casa gana 5%)
            },
            dice: {
                minBet: 50,
                maxBet: 10000,
                cooldown: 30000, // 30 segundos entre juegos
                payouts: {
                    exact: 4.8, // Adivinar n√∫mero exacto: x5.8
                    high: 1.9,  // 4-6: x1.9
                    low: 1.9    // 1-3: x1.9
                }
            },
            guess: {
                minBet: 100,
                maxBet: 5000,
                cooldown: 15000, // 10 segundos
                payouts: {
                    exact: 50,    // N√∫mero exacto: x50
                    close5: 10,   // ¬±5: x10
                    close10: 5,   // ¬±10: x5
                    close20: 2    // ¬±20: x2
                }
            },
            lottery: {
                minBet: 500,
                maxBet: 5000,
                cooldown: 1800000, // 30 minutos (30 * 60 * 1000)
                winMultiplier: 100, // Gana x100 si acierta
                minNumber: 1,
                maxNumber: 100
            },
            blackjack: {
                minBet: 100,
                maxBet: 15000,
                cooldown: 180000,
                blackjackMultiplier: 2.5,
                winMultiplier: 2
            }
        };
        
        this.cooldowns = new Map(); // Para cooldowns por usuario
    }

    // Verificar cooldown de usuario
    checkCooldown(userId, gameType) {
        const key = `${userId}-${gameType}`;
        const lastPlayed = this.cooldowns.get(key) || 0;
        const cooldown = this.config[gameType].cooldown;
        const now = Date.now();
        
        if (now - lastPlayed < cooldown) {
            return {
                onCooldown: true,
                timeLeft: cooldown - (now - lastPlayed)
            };
        }
        
        return { onCooldown: false };
    }

    // Establecer cooldown
    setCooldown(userId, gameType) {
        const key = `${userId}-${gameType}`;
        this.cooldowns.set(key, Date.now());
    }

    // Formatear tiempo
    formatTime(ms) {
        return `${Math.ceil(ms / 1000)}s`;
    }

    // Formatear n√∫meros
    formatNumber(num) {
        return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }
   
    async handleCoinflip(message, args) {
        const userId = message.author.id;
        const user = await this.economy.getUser(userId);
        
        // Al inicio de handleCoinflip y handleDice
/*        if (this.events) {
            this.events.applyEventModifiers(userId, 0, 'games');
        }*/

        // Verificar argumentos
        if (args.length < 3) {
            const embed = new EmbedBuilder()
                .setTitle('ü™ô Coinflip - Cara o Cruz')
                .setDescription('Apuesta a cara o cruz y duplica tu dinero!')
                .addFields(
                    { name: 'üìù Uso', value: '`mon!coinflip <cara/cruz> <cantidad>`', inline: false },
                    { name: 'üí° Ejemplos', value: '`mon!coinflip cara 500`\n`,mon!coinflip cruz 1000`', inline: false },
                    { name: 'üí∞ Apuesta', value: `Min: ${this.formatNumber(this.config.coinflip.minBet)} œÄ-b$\nMax: ${this.formatNumber(this.config.coinflip.maxBet)} œÄ-b$`, inline: false },
                    { name: 'üéØ Probabilidad', value: '50% de ganar\nGanancia: x1.95', inline: false }
                )
                .setColor('#FFD700');
            
            await message.reply({ embeds: [embed] });
            return;
        }

        const choice = args[1].toLowerCase();
        const betAmount = parseInt(args[2]);

        // Validar elecci√≥n
        if (!['cara', 'cruz', 'heads', 'tails', 'h', 't', 'c'].includes(choice)) {
            await message.reply('‚ùå Elige **cara** o **cruz**');
            return;
        }

        // Normalizar elecci√≥n
        const normalizedChoice = ['cara', 'heads', 'h', 'c'].includes(choice) ? 'cara' : 'cruz';

        // Validar cantidad
        if (isNaN(betAmount) || betAmount < this.config.coinflip.minBet || betAmount > this.config.coinflip.maxBet) {
            await message.reply(`‚ùå La apuesta debe ser entre ${this.formatNumber(this.config.coinflip.minBet)} y ${this.formatNumber(this.config.coinflip.maxBet)} œÄ-b$`);
            return;
        }

        // Verificar fondos
        if (user.balance < betAmount) {
            await message.reply(`‚ùå No tienes suficientes œÄ-b Coins. Tu balance: ${this.formatNumber(user.balance)} œÄ-b$`);
            return;
        }

        // Verificar cooldown
        const cooldownCheck = this.checkCooldown(userId, 'coinflip');
        if (cooldownCheck.onCooldown) {
            await message.reply(`‚è∞ Debes esperar ${this.formatTime(cooldownCheck.timeLeft)} antes de jugar otra vez`);
            return;
        }

        // Realizar el juego
        const result = Math.random() < 0.5 ? 'cara' : 'cruz';
        const won = result === normalizedChoice;
        
        // Establecer cooldown
        this.setCooldown(userId, 'coinflip');

        const updateData = {
            'stats.gamesPlayed': (user.stats.gamesPlayed || 0) + 1
        }

        // Crear embed del resultado
        const embed = new EmbedBuilder()
            .setTitle('ü™ô Coinflip - Resultado')
            .setColor(won ? '#00FF00' : '#FF0000')
            .setTimestamp();

        if (won) {
            const winAmount = Math.floor(betAmount * this.config.coinflip.winMultiplier);
            const profit = winAmount - betAmount;
            
            await this.economy.addMoney(userId, profit, 'coinflip_win');            
            await this.economy.updateUser(userId, updateData);
            
            embed.setDescription(`üéâ **¬°GANASTE!**`)
                .addFields(
                    { name: 'ü™ô Resultado', value: result === 'cara' ? 'üü° Cara' : '‚ö™ Cruz', inline: true },
                    { name: 'üéØ Tu Elecci√≥n', value: normalizedChoice === 'cara' ? 'üü° Cara' : '‚ö™ Cruz', inline: true },
                    { name: 'üí∞ Ganancia', value: `+${this.formatNumber(profit)} œÄ-b$`, inline: true },
                    { name: 'üí∏ Balance Antiguo', value: `${this.formatNumber(user.balance)} œÄ-b$`, inline: false },
                    { name: 'üí≥ Balance Actual', value: `${this.formatNumber(user.balance + profit)} œÄ-b$`, inline: false }
                );
        } else {
            await this.economy.removeMoney(userId, betAmount, 'coinflip_loss');            
            await this.economy.updateUser(userId, updateData);

            embed.setDescription(`üí∏ **Perdiste...**`)
                .addFields(
                    { name: 'ü™ô Resultado', value: result === 'cara' ? 'üü° Cara' : '‚ö™ Cruz', inline: true },
                    { name: 'üéØ Tu Elecci√≥n', value: normalizedChoice === 'cara' ? 'üü° Cara' : '‚ö™ Cruz', inline: true },
                    { name: 'üí∏ Perdiste', value: `${this.formatNumber(betAmount)} œÄ-b$`, inline: true },
                    { name: 'üí∏ Balance Antiguo', value: `${this.formatNumber(user.balance)} œÄ-b$`, inline: false },
                    { name: 'üí≥ Balance Actual', value: `${this.formatNumber(user.balance - betAmount)} œÄ-b$`, inline: false }
                );
        }

        await message.reply({ embeds: [embed] });
    }

    async handleDice(message, args) {
        const userId = message.author.id;
        const user = await this.economy.getUser(userId);

/*        if (this.events) {
            this.events.applyEventModifiers(userId, 0, 'games');
        }*/

        // Si no hay argumentos, mostrar ayuda
        if (args.length < 3) {
            const embed = new EmbedBuilder()
                .setTitle('üé≤ Dados - Juego de Predicci√≥n')
                .setDescription('Predice el resultado del dado y gana!')
                .addFields(
                    { name: 'üìù Opciones de Apuesta', value: '‚Ä¢ `1-6`: N√∫mero exacto (x5.8)\n‚Ä¢ `alto`: 4, 5 o 6 (x1.9)\n‚Ä¢ `bajo`: 1, 2 o 3 (x1.9)', inline: false },
                    { name: 'üí° Ejemplos', value: '`mon!dice 6 500` - Apostar al 6\n`mon!dice alto 1000` - Apostar alto\n`mon!dice bajo 750` - Apostar bajo', inline: false },
                    { name: 'üí∞ L√≠mites', value: `Min: ${this.formatNumber(this.config.dice.minBet)} œÄ-b$\nMax: ${this.formatNumber(this.config.dice.maxBet)} œÄ-b$`, inline: false }
                )
                .setColor('#FF6B6B');
            
            await message.reply({ embeds: [embed] });
            return;
        }

        const prediction = args[1].toLowerCase();
        const betAmount = parseInt(args[2]);

        // Validar predicci√≥n
        const validPredictions = ['1', '2', '3', '4', '5', '6', 'alto', 'bajo', 'high', 'low'];
        if (!validPredictions.includes(prediction)) {
            await message.reply('‚ùå Predicci√≥n inv√°lida. Usa: `1-6`, `alto`, o `bajo`');
            return;
        }

        // Validar cantidad
        if (isNaN(betAmount) || betAmount < this.config.dice.minBet || betAmount > this.config.dice.maxBet) {
            await message.reply(`‚ùå La apuesta debe ser entre ${this.formatNumber(this.config.dice.minBet)} y ${this.formatNumber(this.config.dice.maxBet)} œÄ-b$`);
            return;
        }

        // Verificar fondos
        if (user.balance < betAmount) {
            await message.reply(`‚ùå No tienes suficientes œÄ-b Coins. Tu balance: ${this.formatNumber(user.balance)} œÄ-b$`);
            return;
        }

        // Verificar cooldown
        const cooldownCheck = this.checkCooldown(userId, 'dice');
        if (cooldownCheck.onCooldown) {
            await message.reply(`‚è∞ Debes esperar ${this.formatTime(cooldownCheck.timeLeft)} antes de jugar otra vez`);
            return;
        }

        // Tirar el dado
        const diceResult = Math.floor(Math.random() * 6) + 1;
        let won = false;
        let multiplier = 0;

        // Determinar si gan√≥ y el multiplicador
        if (['1', '2', '3', '4', '5', '6'].includes(prediction)) {
            // Predicci√≥n de n√∫mero exacto
            won = diceResult === parseInt(prediction);
            multiplier = this.config.dice.payouts.exact;
        } else if (['alto', 'high'].includes(prediction)) {
            // Predicci√≥n alto (4-6)
            won = diceResult >= 4;
            multiplier = this.config.dice.payouts.high;
        } else if (['bajo', 'low'].includes(prediction)) {
            // Predicci√≥n bajo (1-3)
            won = diceResult <= 3;
            multiplier = this.config.dice.payouts.low;
        }

        // Establecer cooldown
        this.setCooldown(userId, 'dice');
        
        const updateData = {
            'stats.gamesPlayed': (user.stats.gamesPlayed || 0) + 1
        }

        // Emojis del dado
        const diceEmojis = ['', '‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];

        // Crear embed del resultado
        const embed = new EmbedBuilder()
            .setTitle('üé≤ Dados - Resultado')
            .setColor(won ? '#00FF00' : '#FF0000')
            .addFields(
                { name: 'üé≤ Resultado', value: `${diceEmojis[diceResult]} **${diceResult}**`, inline: true },
                { name: 'üéØ Tu Predicci√≥n', value: `**${prediction}**`, inline: true }
            )
            .setTimestamp();

        if (won) {
            const winAmount = Math.floor(betAmount * multiplier);
            const profit = winAmount - betAmount;
            
            await this.economy.addMoney(userId, profit, 'dice_win');
            await this.economy.updateUser(userId, updateData);
            
            embed.setDescription(`üéâ **¬°GANASTE!**`)
                .addFields(
                    { name: 'üí∞ Multiplicador', value: `x${multiplier}`, inline: true },
                    { name: 'üí∞ Ganancia', value: `+${this.formatNumber(profit)} œÄ-b$`, inline: false },
                    { name: 'üí∏ Balance Antiguo', value: `${this.formatNumber(user.balance)} œÄ-b$`, inline: false },
                    { name: 'üí≥ Balance Actual', value: `${this.formatNumber(user.balance + profit)} œÄ-b$`, inline: false }
                );
        } else {
            await this.economy.removeMoney(userId, betAmount, 'dice_loss');
            await this.economy.updateUser(userId, updateData);
            
            embed.setDescription(`üí∏ **Perdiste...**`)
                .addFields(
                    { name: 'üí∞ Dinero Apostado', value: `${this.formatNumber(betAmount)} œÄ-b$`, inline: false },
                    { name: 'üí∏ Balance Antiguo', value: `${this.formatNumber(user.balance)} œÄ-b$`, inline: false },
                    { name: 'üí≥ Balance Actual', value: `${this.formatNumber(user.balance - betAmount)} œÄ-b$`, inline: false },
                );
        }

        await message.reply({ embeds: [embed] });
    }

    // M√©todo para manejar la loter√≠a (agregar a la clase MinigamesSystem)
    async handleLottery(message, args) {
        const userId = message.author.id;
        const user = await this.economy.getUser(userId);
    
        // Si no hay argumentos suficientes, mostrar ayuda
        if (args.length < 3) {
            const embed = new EmbedBuilder()
                .setTitle('üé∞ Loter√≠a - Juego de la Suerte')
                .setDescription('¬°Predice el n√∫mero ganador y multiplica tu dinero x100!')
                .addFields(
                    { name: 'üìù Uso', value: '`mon!lottery <n√∫mero> <cantidad>`', inline: false },
                    { name: 'üí° Ejemplos', value: '`mon!lottery 50 1000`\n`mon!lottery 25 2500`', inline: false },
                    { name: 'üéØ Rango de N√∫meros', value: `${this.config.lottery.minNumber} - ${this.config.lottery.maxNumber}`, inline: true },
                    { name: 'üí∞ Apuesta', value: `Min: ${this.formatNumber(this.config.lottery.minBet)} œÄ-b$\nMax: ${this.formatNumber(this.config.lottery.maxBet)} œÄ-b$`, inline: true },
                    { name: 'üèÜ Ganancia', value: `x${this.config.lottery.winMultiplier} si aciertas\n(Probabilidad: 1%)`, inline: true },
                    { name: '‚è∞ Cooldown', value: '30 minutos', inline: false }
                )
                .setColor('#FF1493')
                .setFooter({ text: '¬°Un juego de pura suerte! ¬øTe sientes con suerte?' });
            
            await message.reply({ embeds: [embed] });
            return;
        }
    
        const predictedNumber = parseInt(args[1]);
        const betAmount = parseInt(args[2]);
    
        // Validar n√∫mero predicho
        if (isNaN(predictedNumber) || predictedNumber < this.config.lottery.minNumber || predictedNumber > this.config.lottery.maxNumber) {
            await message.reply(`‚ùå El n√∫mero debe ser entre ${this.config.lottery.minNumber} y ${this.config.lottery.maxNumber}`);
            return;
        }
    
        // Validar cantidad de apuesta
        if (isNaN(betAmount) || betAmount < this.config.lottery.minBet || betAmount > this.config.lottery.maxBet) {
            await message.reply(`‚ùå La apuesta debe ser entre ${this.formatNumber(this.config.lottery.minBet)} y ${this.formatNumber(this.config.lottery.maxBet)} œÄ-b$`);
            return;
        }
    
        // Verificar fondos
        if (user.balance < betAmount) {
            await message.reply(`‚ùå No tienes suficientes œÄ-b Coins. Tu balance: ${this.formatNumber(user.balance)} œÄ-b$`);
            return;
        }
    
        // Verificar cooldown
        const cooldownCheck = this.checkCooldown(userId, 'lottery');
        if (cooldownCheck.onCooldown) {
            const timeLeft = Math.ceil(cooldownCheck.timeLeft / 60000); // Convertir a minutos
            await message.reply(`‚è∞ Debes esperar ${timeLeft} minutos antes de jugar la loter√≠a otra vez`);
            return;
        }
    
        // Generar n√∫mero ganador
        const winningNumber = Math.floor(Math.random() * this.config.lottery.maxNumber) + this.config.lottery.minNumber;
        const won = winningNumber === predictedNumber;
        
        // Establecer cooldown
        this.setCooldown(userId, 'lottery');
        
        const updateData = {
            'stats.gamesPlayed': (user.stats.gamesPlayed || 0) + 1
        };
    
        // Crear embed del resultado con animaci√≥n
        const loadingEmbed = new EmbedBuilder()
            .setTitle('üé∞ Loter√≠a - Sorteando...')
            .setDescription('üé≤ **Generando n√∫mero ganador...**\n\nüîÑ Espera un momento...')
            .addFields(
                { name: 'üéØ Tu N√∫mero', value: `**${predictedNumber}**`, inline: true },
                { name: 'üí∞ Apuesta', value: `${this.formatNumber(betAmount)} œÄ-b$`, inline: true }
            )
            .setColor('#FFD700');
    
        const reply = await message.reply({ embeds: [loadingEmbed] });
    
        // Simular suspense con un delay
        await new Promise(resolve => setTimeout(resolve, 3000));
    
        // Crear embed del resultado final
        const resultEmbed = new EmbedBuilder()
            .setTitle('üé∞ Loter√≠a - Resultado')
            .setColor(won ? '#00FF00' : '#FF0000')
            .addFields(
                { name: 'üéØ Tu N√∫mero', value: `**${predictedNumber}**`, inline: true },
                { name: 'üèÜ N√∫mero Ganador', value: `**${winningNumber}**`, inline: true },
                { name: 'üí∞ Apuesta', value: `${this.formatNumber(betAmount)} œÄ-b$`, inline: true }
            )
            .setTimestamp();
    
        if (won) {
            const winAmount = betAmount * this.config.lottery.winMultiplier;
            const profit = winAmount - betAmount;
            
            await this.economy.addMoney(userId, profit, 'lottery_win');            
            await this.economy.updateUser(userId, updateData);
            
            resultEmbed.setDescription(`üéâ **¬°JACKPOT! ¬°GANASTE LA LOTER√çA!** üéâ`)
                .addFields(
                    { name: 'üéä ¬°Incre√≠ble!', value: `¬°Acertaste el n√∫mero exacto!`, inline: false },
                    { name: 'üíé Multiplicador', value: `x${this.config.lottery.winMultiplier}`, inline: true },
                    { name: 'ü§ë Ganancia Total', value: `+${this.formatNumber(profit)} œÄ-b$`, inline: true },
                    { name: 'üí∏ Balance Anterior', value: `${this.formatNumber(user.balance)} œÄ-b$`, inline: false },
                    { name: 'üí≥ Balance Actual', value: `${this.formatNumber(user.balance + profit)} œÄ-b$ üöÄ`, inline: false }
                );
        } else {
            await this.economy.removeMoney(userId, betAmount, 'lottery_loss');
            await this.economy.updateUser(userId, updateData);
            
            const difference = Math.abs(winningNumber - predictedNumber);
            let encouragement = '';
            
            if (difference === 1) {
                encouragement = 'üò± ¬°Por solo 1 n√∫mero! ¬°Tan cerca!';
            } else if (difference <= 5) {
                encouragement = 'üòî ¬°Muy cerca! Solo te faltaron unos n√∫meros';
            } else if (difference <= 10) {
                encouragement = 'ü§î No estuvo mal, ¬°sigue intentando!';
            } else {
                encouragement = 'üéØ ¬°La pr√≥xima ser√° tu momento de suerte!';
            }
            
            resultEmbed.setDescription(`üí∏ **No ganaste esta vez...** ${encouragement}`)
                .addFields(
                    { name: 'üìä Diferencia', value: `${difference} n√∫meros`, inline: true },
                    { name: 'üí∏ Perdiste', value: `${this.formatNumber(betAmount)} œÄ-b$`, inline: true },
                    { name: 'üí∏ Balance Anterior', value: `${this.formatNumber(user.balance)} œÄ-b$`, inline: false },
                    { name: 'üí≥ Balance Actual', value: `${this.formatNumber(user.balance - betAmount)} œÄ-b$`, inline: false },
                    { name: 'üí° Consejo', value: 'La loter√≠a es pura suerte. ¬°Cada n√∫mero tiene la misma probabilidad!', inline: false }
                );
        }
    
        await reply.edit({ embeds: [resultEmbed] });
    }

    // Agregar estos m√©todos a tu clase MinigamesSystem
    
    async handleBlackjack(message, args) {
        const userId = message.author.id;
        const user = await this.economy.getUser(userId);
    
        // Si no hay argumentos suficientes, mostrar ayuda
        if (args.length < 2) {
            const embed = new EmbedBuilder()
                .setTitle('‚ô†Ô∏è Blackjack - Vence al Dealer')
                .setDescription('¬°Llega lo m√°s cerca posible a 21 sin pasarte!')
                .addFields(
                    { name: 'üìù Uso', value: '`mon!blackjack <cantidad>`', inline: false },
                    { name: 'üí° Ejemplos', value: '`mon!blackjack 500`\n`mon!blackjack 2000`', inline: false },
                    { name: 'üí∞ Apuesta', value: `Min: ${this.formatNumber(this.config.blackjack.minBet)} œÄ-b$\nMax: ${this.formatNumber(this.config.blackjack.maxBet)} œÄ-b$`, inline: false },
                    { name: 'üéØ Reglas', value: '‚Ä¢ Llega a 21 o cerca sin pasarte\n‚Ä¢ As vale 1 u 11\n‚Ä¢ Figuras valen 10\n‚Ä¢ Blackjack natural: x2.5\n‚Ä¢ Victoria normal: x2', inline: false },
                    { name: 'üéÆ Controles', value: 'üéØ **Hit** - Pedir carta\nüõë **Stand** - Plantarse\nüîÑ **Double** - Doblar apuesta', inline: false }
                )
                .setColor('#000000')
                .setFooter({ text: 'Cooldown: 3 minutos' });
            
            await message.reply({ embeds: [embed] });
            return;
        }
    
        const betAmount = parseInt(args[1]);
    
        // Validar cantidad de apuesta
        if (isNaN(betAmount) || betAmount < this.config.blackjack.minBet || betAmount > this.config.blackjack.maxBet) {
            await message.reply(`‚ùå La apuesta debe ser entre ${this.formatNumber(this.config.blackjack.minBet)} y ${this.formatNumber(this.config.blackjack.maxBet)} œÄ-b$`);
            return;
        }
    
        // Verificar fondos
        if (user.balance < betAmount) {
            await message.reply(`‚ùå No tienes suficientes œÄ-b Coins. Tu balance: ${this.formatNumber(user.balance)} œÄ-b$`);
            return;
        }
    
        // Verificar cooldown
        const cooldownCheck = this.checkCooldown(userId, 'blackjack');
        if (cooldownCheck.onCooldown) {
            const timeLeft = Math.ceil(cooldownCheck.timeLeft / 60000); // Convertir a minutos
            await message.reply(`‚è∞ Debes esperar ${timeLeft} minutos antes de jugar otra vez`);
            return;
        }
    
        // Verificar si ya hay un juego activo
        if (this.activeGames.has(`blackjack_${userId}`)) {
            await message.reply('‚ùå Ya tienes un juego de Blackjack activo. Term√≠nalo primero.');
            return;
        }
    
        // Crear nuevo juego
        await this.startBlackjackGame(message, userId, betAmount);
    }
    
    async startBlackjackGame(message, userId, betAmount) {
        // Crear mazo y repartir cartas
        const deck = this.createDeck();
        const playerHand = [this.drawCard(deck), this.drawCard(deck)];
        const dealerHand = [this.drawCard(deck), this.drawCard(deck)];
    
        const gameState = {
            userId,
            betAmount,
            deck,
            playerHand,
            dealerHand,
            doubled: false,
            finished: false
        };
    
        this.activeGames.set(`blackjack_${userId}`, gameState);
    
        // Verificar Blackjack natural
        const playerValue = this.calculateHandValue(playerHand);
        const dealerValue = this.calculateHandValue(dealerHand);
    
        if (playerValue === 21) {
            if (dealerValue === 21) {
                await this.finishBlackjack(message, gameState, 'push');
            } else {
                await this.finishBlackjack(message, gameState, 'blackjack');
            }
            return;
        }
    
        // Mostrar juego con botones
        await this.showBlackjackState(message, gameState);
    }
    
    async showBlackjackState(message, gameState) {
        const { playerHand, dealerHand, betAmount, doubled } = gameState;
        const playerValue = this.calculateHandValue(playerHand);
    
        const embed = new EmbedBuilder()
            .setTitle('‚ô†Ô∏è Blackjack - En Juego')
            .setColor('#FFD700')
            .addFields(
                { 
                    name: 'üé¥ Dealer', 
                    value: `${this.formatHand(dealerHand, true)}\nValor: ?`, 
                    inline: false 
                },
                { 
                    name: 'üë§ Tu Mano', 
                    value: `${this.formatHand(playerHand)}\nValor: **${playerValue}**`, 
                    inline: false 
                },
                { 
                    name: 'üí∞ Apuesta', 
                    value: `${this.formatNumber(doubled ? betAmount * 2 : betAmount)} œÄ-b$`, 
                    inline: true 
                }
            )
            .setTimestamp();
    
        // Verificar si se pas√≥
        if (playerValue > 21) {
            await this.finishBlackjack(message, gameState, 'bust');
            return;
        }
    
        // Crear botones
        const buttons = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`bj_hit_${gameState.userId}`)
                    .setLabel('üéØ Hit')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId(`bj_stand_${gameState.userId}`)
                    .setLabel('üõë Stand')
                    .setStyle(ButtonStyle.Secondary)
            );
    
        // Bot√≥n doblar si es posible
        const user = await this.economy.getUser(gameState.userId);
        if (playerHand.length === 2 && !doubled && user.balance >= betAmount) {
            buttons.addComponents(
                new ButtonBuilder()
                    .setCustomId(`bj_double_${gameState.userId}`)
                    .setLabel('üîÑ Double')
                    .setStyle(ButtonStyle.Success)
            );
        }
    
        const reply = await message.reply({ embeds: [embed], components: [buttons] });
        gameState.messageId = reply.id;
        gameState.channelId = reply.channel.id;
    
        // Timeout autom√°tico
        setTimeout(() => {
            if (this.activeGames.has(`blackjack_${gameState.userId}`)) {
                this.handleBlackjackAction(null, gameState.userId, 'stand');
            }
        }, 60000);
    }
    
    async handleBlackjackAction(interaction, userId, action) {
        const gameState = this.activeGames.get(`blackjack_${userId}`);
        if (!gameState || gameState.finished) {
            if (interaction) {
                await interaction.reply({ content: '‚ùå Este juego ya termin√≥.', ephemeral: true });
            }
            return;
        }
    
        if (interaction) {
            await interaction.deferUpdate();
        }
    
        switch (action) {
            case 'hit':
                await this.blackjackHit(interaction, gameState);
                break;
            case 'stand':
                await this.blackjackStand(interaction, gameState);
                break;
            case 'double':
                await this.blackjackDouble(interaction, gameState);
                break;
        }
    }
    
    async blackjackHit(interaction, gameState) {
        const newCard = this.drawCard(gameState.deck);
        gameState.playerHand.push(newCard);
        
        const playerValue = this.calculateHandValue(gameState.playerHand);
        
        if (playerValue > 21) {
            await this.finishBlackjack(interaction, gameState, 'bust');
        } else if (playerValue === 21) {
            await this.blackjackStand(interaction, gameState);
        } else {
            await this.updateBlackjackMessage(interaction, gameState);
        }
    }
    
    async blackjackStand(interaction, gameState) {
        gameState.finished = true;
        
        // Dealer juega
        while (this.calculateHandValue(gameState.dealerHand) < 17) {
            gameState.dealerHand.push(this.drawCard(gameState.deck));
        }
        
        const dealerValue = this.calculateHandValue(gameState.dealerHand);
        const playerValue = this.calculateHandValue(gameState.playerHand);
        
        let result;
        if (dealerValue > 21) {
            result = 'dealer_bust';
        } else if (playerValue > dealerValue) {
            result = 'win';
        } else if (playerValue < dealerValue) {
            result = 'lose';
        } else {
            result = 'push';
        }
        
        await this.finishBlackjack(interaction, gameState, result);
    }
    
    async blackjackDouble(interaction, gameState) {
        const user = await this.economy.getUser(gameState.userId);
        
        if (user.balance < gameState.betAmount) {
            if (interaction) {
                await interaction.followUp({ content: '‚ùå No tienes suficiente dinero para doblar.', ephemeral: true });
            }
            return;
        }
        
        gameState.doubled = true;
        gameState.playerHand.push(this.drawCard(gameState.deck));
        
        const playerValue = this.calculateHandValue(gameState.playerHand);
        
        if (playerValue > 21) {
            await this.finishBlackjack(interaction, gameState, 'bust');
        } else {
            await this.blackjackStand(interaction, gameState);
        }
    }
    
    async updateBlackjackMessage(interaction, gameState) {
        const { playerHand, dealerHand, betAmount, doubled } = gameState;
        const playerValue = this.calculateHandValue(playerHand);
    
        const embed = new EmbedBuilder()
            .setTitle('‚ô†Ô∏è Blackjack - En Juego')
            .setColor('#FFD700')
            .addFields(
                { 
                    name: 'üé¥ Dealer', 
                    value: `${this.formatHand(dealerHand, true)}\nValor: ?`, 
                    inline: false 
                },
                { 
                    name: 'üë§ Tu Mano', 
                    value: `${this.formatHand(playerHand)}\nValor: **${playerValue}**`, 
                    inline: false 
                },
                { 
                    name: 'üí∞ Apuesta', 
                    value: `${this.formatNumber(doubled ? betAmount * 2 : betAmount)} œÄ-b$`, 
                    inline: true 
                }
            )
            .setTimestamp();
    
        const buttons = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`bj_hit_${gameState.userId}`)
                    .setLabel('üéØ Hit')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId(`bj_stand_${gameState.userId}`)
                    .setLabel('üõë Stand')
                    .setStyle(ButtonStyle.Secondary)
            );
    
        if (interaction && interaction.editReply) {
            await interaction.editReply({ embeds: [embed], components: [buttons] });
        }
    }
    
    async finishBlackjack(messageOrInteraction, gameState, result) {
        gameState.finished = true;
        this.activeGames.delete(`blackjack_${gameState.userId}`);
        
        const { userId, betAmount, playerHand, dealerHand, doubled } = gameState;
        const user = await this.economy.getUser(userId);
        
        const finalBet = doubled ? betAmount * 2 : betAmount;
        const playerValue = this.calculateHandValue(playerHand);
        const dealerValue = this.calculateHandValue(dealerHand);
        
        this.setCooldown(userId, 'blackjack');
        
        const updateData = {
            'stats.gamesPlayed': (user.stats.gamesPlayed || 0) + 1
        };
        
        let profit = 0;
        let resultText = '';
        let color = '#FF0000';
        
        switch (result) {
            case 'blackjack':
                const blackjackWin = Math.floor(betAmount * this.config.blackjack.blackjackMultiplier);
                profit = blackjackWin - betAmount;
                resultText = 'üéâ **¬°BLACKJACK NATURAL!**';
                color = '#00FF00';
                await this.economy.addMoney(userId, profit, 'blackjack_win');
                break;
            case 'win':
            case 'dealer_bust':
                const normalWin = finalBet * this.config.blackjack.winMultiplier;
                profit = normalWin - finalBet;
                resultText = result === 'dealer_bust' ? 'üéâ **¬°DEALER SE PAS√ì!**' : 'üéâ **¬°GANASTE!**';
                color = '#00FF00';
                await this.economy.addMoney(userId, profit, 'blackjack_win');
                break;
            case 'push':
                resultText = 'ü§ù **¬°EMPATE!**';
                color = '#FFD700';
                break;
            case 'bust':
                resultText = 'üí• **¬°TE PASASTE!**';
                profit = -finalBet;
                await this.economy.removeMoney(userId, finalBet, 'blackjack_loss');
                break;
            case 'lose':
                resultText = 'üí∏ **Perdiste...**';
                profit = -finalBet;
                await this.economy.removeMoney(userId, finalBet, 'blackjack_loss');
                break;
        }
        
        await this.economy.updateUser(userId, updateData);
        
        const embed = new EmbedBuilder()
            .setTitle('‚ô†Ô∏è Blackjack - Resultado')
            .setDescription(resultText)
            .setColor(color)
            .addFields(
                { 
                    name: 'üé¥ Dealer', 
                    value: `${this.formatHand(dealerHand)}\nValor: **${dealerValue}**`, 
                    inline: true 
                },
                { 
                    name: 'üë§ Tu Mano', 
                    value: `${this.formatHand(playerHand)}\nValor: **${playerValue}**`, 
                    inline: true 
                },
                { 
                    name: 'üí∞ Apuesta', 
                    value: `${this.formatNumber(finalBet)} œÄ-b$`, 
                    inline: true 
                }
            );
    
        if (profit > 0) {
            embed.addFields(
                { name: 'üí∞ Ganancia', value: `+${this.formatNumber(profit)} œÄ-b$`, inline: true },
                { name: 'üí≥ Balance Actual', value: `${this.formatNumber(user.balance + profit)} œÄ-b$`, inline: true }
            );
        } else if (profit < 0) {
            embed.addFields(
                { name: 'üí∏ Perdiste', value: `${this.formatNumber(Math.abs(profit))} œÄ-b$`, inline: true },
                { name: 'üí≥ Balance Actual', value: `${this.formatNumber(user.balance + profit)} œÄ-b$`, inline: true }
            );
        } else {
            embed.addFields(
                { name: 'üí≥ Balance', value: `${this.formatNumber(user.balance)} œÄ-b$ (Sin cambios)`, inline: true }
            );
        }
        
        if (doubled) {
            embed.addFields({ name: 'üîÑ Especial', value: 'Apuesta doblada', inline: true });
        }
    
        embed.setTimestamp();
    
        // Enviar resultado
        if (messageOrInteraction && messageOrInteraction.editReply) {
            await messageOrInteraction.editReply({ embeds: [embed], components: [] });
        } else if (messageOrInteraction && messageOrInteraction.reply) {
            await messageOrInteraction.reply({ embeds: [embed] });
        }
    }
    
    // M√©todos auxiliares
    createDeck() {
        const suits = ['‚ô†Ô∏è', '‚ô•Ô∏è', '‚ô¶Ô∏è', '‚ô£Ô∏è'];
        const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const deck = [];
    
        for (const suit of suits) {
            for (const rank of ranks) {
                deck.push({ suit, rank });
            }
        }
    
        // Mezclar
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
    
        return deck;
    }
    
    drawCard(deck) {
        return deck.pop();
    }
    
    calculateHandValue(hand) {
        let value = 0;
        let aces = 0;
    
        for (const card of hand) {
            if (card.rank === 'A') {
                aces++;
                value += 11;
            } else if (['J', 'Q', 'K'].includes(card.rank)) {
                value += 10;
            } else {
                value += parseInt(card.rank);
            }
        }
    
        while (value > 21 && aces > 0) {
            value -= 10;
            aces--;
        }
    
        return value;
    }
    
    formatHand(hand, hideFirst = false) {
        if (hideFirst) {
            return `üé¥ ${hand.slice(1).map(card => `${card.rank}${card.suit}`).join(' ')}`;
        }
        return hand.map(card => `${card.rank}${card.suit}`).join(' ');
    }
    
    // Manejador de botones (agregar a tu sistema principal)
    async handleBlackjackButtons(interaction) {
        if (!interaction.customId.startsWith('bj_')) return;
    
        const [, action, userId] = interaction.customId.split('_');
        
        if (interaction.user.id !== userId) {
            await interaction.reply({ content: '‚ùå Este no es tu juego.', ephemeral: true });
            return;
        }
    
        await this.handleBlackjackAction(interaction, userId, action);
    }    
    async processCommand(message) {
        if (message.author.bot) return;

        const args = message.content.toLowerCase().split(' ');
        const command = args[0];

        try {
            switch (command) {
                case 'mon!coinflip':
                case 'mon!cf':
                case 'mon!coin':
                    await this.handleCoinflip(message, args);
                    break;
                case 'mon!dice':
                case 'mon!dado':
                case 'mon!d':
                    await this.handleDice(message, args);
                    break;
                case 'mon!lottery':
                case 'mon!loteria':
                case 'mon!lotto':
                    await this.handleLottery(message, args);
                    break;
                case 'mon!blackjack':
                case 'mon!bj':
                case 'mon!21':
                    await this.handleBlackjack(message, args);
                    break;
                case 'mon!games':
                case 'mon!minigames':
                case 'mon!juegos':
                    await this.showGamesList(message);
                    break;
                default:
                    // No es un comando de minijuegos
                    break;
            }
        } catch (error) {
            console.error('‚ùå Error en minijuegos:', error);
            await message.reply('‚ùå Ocurri√≥ un error en el juego. Intenta de nuevo.');
        }
    }

    // Mostrar lista de juegos disponibles
    async showGamesList(message) {
        const embed = new EmbedBuilder()
            .setTitle('üéÆ Minijuegos Disponibles')
            .setDescription('¬°Divi√©rtete y gana œÄ-b Coins!')
            .setColor('#9932CC')
            .addFields(
                { 
                    name: 'ü™ô Coinflip', 
                    value: '`mon!coinflip <cara/cruz> <cantidad>`\nApuesta: 50-10,000 œÄ-b$\nGanancia: x1.95\nCooldown: 15 segundos', 
                    inline: false 
                },
                { 
                    name: 'üé≤ Dados', 
                    value: '`mon!dice <1-6/alto/bajo> <cantidad>`\nApuesta: 50-10,000 œÄ-b$\nGanancia: x1.9 - x5.8\nCooldown: 30 segundos', 
                    inline: false 
                },
                { 
                    name: 'üé∞ Loter√≠a', 
                    value: '`mon!lottery <n√∫mero> <cantidad>`\nApuesta: 500-5,000 œÄ-b$\nGanancia: x100 (¬°Si aciertas!)\nCooldown: 30 minutos', 
                    inline: false 
                },
                { 
                    name: '‚ô†Ô∏è Blackjack', 
                    value: '`mon!blackjack <cantidad>`\nApuesta: 100-15,000 œÄ-b$\nGanancia: x2 (x2.5 con Blackjack natural)\nCooldown: 3 minutos', 
                    inline: false 
                },
                { 
                    name: 'üîÆ Pr√≥ximamente', 
                    value: '‚Ä¢ Ruleta\n‚Ä¢ Slots', 
                    inline: false 
                }
            )
            .setFooter({ text: 'Juega responsablemente - La casa siempre tiene ventaja' })
            .setTimestamp();

        await message.reply({ embeds: [embed] });
    }
}

module.exports = MinigamesSystem;
