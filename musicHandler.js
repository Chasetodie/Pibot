const { joinVoiceChannel, createAudioPlayer, createAudioResource, AudioPlayerStatus, VoiceConnectionStatus, StreamType } = require('@discordjs/voice');
const playdl = require('play-dl');

class MusicHandler {
    constructor() {
        this.queue = new Map();
        this.initializePlayDl();
    }

    async initializePlayDl() {
        try {
            // Solo configurar si es necesario
            console.log('üéµ Iniciando sistema de m√∫sica...');
        } catch (error) {
            console.log('‚ö†Ô∏è Advertencia al inicializar play-dl:', error.message);
        }
    }

    // Estructura de datos para cada servidor
    createQueueConstruct(textChannel, voiceChannel) {
        return {
            textChannel: textChannel,
            voiceChannel: voiceChannel,
            connection: null,
            songs: [],
            volume: 5,
            playing: true,
            player: createAudioPlayer()
        };
    }

    // Buscar videos en YouTube
    async searchYoutube(query) {
        try {
            const searched = await playdl.search(query, {
                limit: 1,
                source: { youtube: "video" }
            });
            
            if (searched.length > 0) {
                const video = searched[0];
                return {
                    title: video.title,
                    url: video.url,
                    duration: video.durationInSec,
                    thumbnail: video.thumbnails[0]?.url || null,
                    channel: video.channel?.name || 'Desconocido'
                };
            }
            return null;
        } catch (error) {
            console.error('Error buscando en YouTube:', error);
            return null;
        }
    }

    // Validar URL de YouTube
    isValidYouTubeUrl(url) {
        try {
            return playdl.yt_validate(url) === 'video';
        } catch {
            return false;
        }
    }

    // Obtener informaci√≥n del video
    async getVideoInfo(url) {
        try {
            const info = await playdl.video_info(url);
            const video = info.video_details;
            
            return {
                title: video.title,
                url: video.url,
                duration: video.durationInSec,
                thumbnail: video.thumbnails[0]?.url || null,
                channel: video.channel?.name || 'Desconocido'
            };
        } catch (error) {
            console.error('Error obteniendo info del video:', error);
            return null;
        }
    }

    // Reproducir m√∫sica
    async play(message, song) {
        const queue = this.queue.get(message.guild.id);
        
        if (!song) {
            if (queue?.connection) {
                queue.connection.destroy();
            }
            this.queue.delete(message.guild.id);
            return message.channel.send('üèÅ **Cola de reproducci√≥n terminada.** ¬°Gracias por usar el bot!');
        }

        try {
            // Obtener stream de audio
            const stream = await playdl.stream(song.url, { 
                quality: 2 // Calidad media para mayor estabilidad
            });
            
            const resource = createAudioResource(stream.stream, {
                inputType: stream.type,
                inlineVolume: true
            });
            
            // Configurar volumen
            if (resource.volume) {
                resource.volume.setVolume(0.5);
            }
            
            queue.player.play(resource);
            
            if (queue.connection) {
                queue.connection.subscribe(queue.player);
            }

            // Eventos del reproductor
            queue.player.on(AudioPlayerStatus.Playing, () => {
                const embed = {
                    color: 0x00ff00,
                    title: 'üéµ Reproduciendo Ahora',
                    description: `**${song.title}**`,
                    fields: [
                        { name: 'üì∫ Canal', value: song.channel, inline: true },
                        { name: '‚è±Ô∏è Duraci√≥n', value: this.formatDuration(song.duration), inline: true }
                    ],
                    thumbnail: { url: song.thumbnail || '' },
                    timestamp: new Date()
                };
                message.channel.send({ embeds: [embed] });
            });

            queue.player.on(AudioPlayerStatus.Idle, () => {
                queue.songs.shift();
                setTimeout(() => {
                    this.play(message, queue.songs[0]);
                }, 1000);
            });

            queue.player.on('error', error => {
                console.error('‚ùå Error del reproductor:', error);
                message.channel.send('‚ùå Error reproduciendo la canci√≥n. Saltando...');
                queue.songs.shift();
                setTimeout(() => {
                    this.play(message, queue.songs[0]);
                }, 2000);
            });

        } catch (error) {
            console.error('‚ùå Error reproduciendo:', error);
            message.channel.send(`‚ùå No se pudo reproducir: **${song.title}**`);
            queue.songs.shift();
            setTimeout(() => {
                this.play(message, queue.songs[0]);
            }, 2000);
        }
    }

    // Comando principal de reproducir
    async execute(message, args) {
        const voiceChannel = message.member.voice.channel;
        if (!voiceChannel) {
            return message.channel.send('‚ùå ¬°Necesitas estar en un canal de voz para reproducir m√∫sica!');
        }

        const permissions = voiceChannel.permissionsFor(message.client.user);
        if (!permissions.has('Connect') || !permissions.has('Speak')) {
            return message.channel.send('‚ùå No tengo permisos para unirme o hablar en tu canal de voz!');
        }

        if (!args.length) {
            return message.channel.send('‚ùå **Uso:** `!play <URL de YouTube o t√©rmino de b√∫squeda>`\n**Ejemplo:** `!play Never Gonna Give You Up`');
        }

        const serverQueue = this.queue.get(message.guild.id);
        let song = {};

        // Mostrar mensaje de "buscando..."
        const searchMessage = await message.channel.send('üîç **Buscando m√∫sica...** ‚è≥');

        try {
            // Determinar si es URL o b√∫squeda
            if (this.isValidYouTubeUrl(args[0])) {
                const videoInfo = await this.getVideoInfo(args[0]);
                if (!videoInfo) {
                    await searchMessage.edit('‚ùå No se pudo obtener informaci√≥n del video. Verifica que la URL sea v√°lida.');
                    return;
                }
                song = videoInfo;
            } else {
                // Buscar en YouTube
                const searchResult = await this.searchYoutube(args.join(' '));
                if (!searchResult) {
                    await searchMessage.edit('‚ùå No se encontraron resultados para tu b√∫squeda. Intenta con otros t√©rminos.');
                    return;
                }
                song = searchResult;
            }

            await searchMessage.delete().catch(() => {});

            // Si no hay cola, crear una nueva
            if (!serverQueue) {
                const queueConstruct = this.createQueueConstruct(message.channel, voiceChannel);
                this.queue.set(message.guild.id, queueConstruct);

                queueConstruct.songs.push(song);

                try {
                    const connection = joinVoiceChannel({
                        channelId: voiceChannel.id,
                        guildId: message.guild.id,
                        adapterCreator: message.guild.voiceAdapterCreator,
                    });

                    queueConstruct.connection = connection;

                    connection.on(VoiceConnectionStatus.Ready, () => {
                        console.log('‚úÖ Conexi√≥n establecida y lista!');
                    });

                    connection.on(VoiceConnectionStatus.Disconnected, () => {
                        console.log('üîå Bot desconectado del canal de voz');
                    });

                    connection.on('error', error => {
                        console.error('‚ùå Error de conexi√≥n:', error);
                    });

                    this.play(message, queueConstruct.songs[0]);
                } catch (error) {
                    console.error('‚ùå Error conectando al canal:', error);
                    this.queue.delete(message.guild.id);
                    return message.channel.send('‚ùå Error conectando al canal de voz. Intenta de nuevo.');
                }
            } else {
                serverQueue.songs.push(song);
                const embed = {
                    color: 0x0099ff,
                    title: '‚úÖ A√±adida a la Cola',
                    description: `**${song.title}**`,
                    fields: [
                        { name: 'üìç Posici√≥n en cola', value: `${serverQueue.songs.length}`, inline: true },
                        { name: '‚è±Ô∏è Duraci√≥n', value: this.formatDuration(song.duration), inline: true }
                    ],
                    thumbnail: { url: song.thumbnail || '' },
                    timestamp: new Date()
                };
                return message.channel.send({ embeds: [embed] });
            }
        } catch (error) {
            console.error('‚ùå Error en execute:', error);
            await searchMessage.edit('‚ùå Ocurri√≥ un error procesando tu solicitud. Intenta de nuevo.').catch(() => {});
        }
    }

    // Resto de m√©todos (stop, skip, queue, etc.) permanecen igual...
    stop(message) {
        const serverQueue = this.queue.get(message.guild.id);
        if (!serverQueue) {
            return message.channel.send('‚ùå No hay m√∫sica reproduci√©ndose!');
        }

        serverQueue.songs = [];
        serverQueue.player.stop();
        if (serverQueue.connection) {
            serverQueue.connection.destroy();
        }
        this.queue.delete(message.guild.id);
        
        return message.channel.send('‚èπÔ∏è **M√∫sica detenida** y bot desconectado! üëã');
    }

    skip(message) {
        const serverQueue = this.queue.get(message.guild.id);
        if (!serverQueue) {
            return message.channel.send('‚ùå No hay m√∫sica que saltar!');
        }

        serverQueue.player.stop();
        return message.channel.send('‚è≠Ô∏è **Canci√≥n saltada!**');
    }

    showQueue(message) {
        const serverQueue = this.queue.get(message.guild.id);
        if (!serverQueue || !serverQueue.songs.length) {
            return message.channel.send('‚ùå No hay m√∫sica en cola!');
        }

        const embed = {
            color: 0x0099FF,
            title: 'üéµ Cola de Reproducci√≥n',
            fields: [],
            footer: { text: `Total: ${serverQueue.songs.length} canci√≥n(es)` },
            timestamp: new Date(),
        };

        serverQueue.songs.slice(0, 10).forEach((song, index) => {
            const status = index === 0 ? 'üîä **Reproduciendo**' : `${index}. En cola`;
            embed.fields.push({
                name: status,
                value: `**${song.title}**\n‚è±Ô∏è ${this.formatDuration(song.duration)} ‚Ä¢ üì∫ ${song.channel}`,
                inline: false
            });
        });

        if (serverQueue.songs.length > 10) {
            embed.description = `... y ${serverQueue.songs.length - 10} canci√≥n(es) m√°s`;
        }

        return message.channel.send({ embeds: [embed] });
    }

    formatDuration(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    }

    pause(message) {
        const serverQueue = this.queue.get(message.guild.id);
        if (!serverQueue) {
            return message.channel.send('‚ùå No hay m√∫sica reproduci√©ndose!');
        }

        if (serverQueue.player.state.status === AudioPlayerStatus.Playing) {
            serverQueue.player.pause();
            return message.channel.send('‚è∏Ô∏è **M√∫sica pausada!**');
        } else {
            return message.channel.send('‚ùå La m√∫sica ya est√° pausada!');
        }
    }

    resume(message) {
        const serverQueue = this.queue.get(message.guild.id);
        if (!serverQueue) {
            return message.channel.send('‚ùå No hay m√∫sica que reanudar!');
        }

        if (serverQueue.player.state.status === AudioPlayerStatus.Paused) {
            serverQueue.player.unpause();
            return message.channel.send('‚ñ∂Ô∏è **M√∫sica reanudada!**');
        } else {
            return message.channel.send('‚ùå La m√∫sica no est√° pausada!');
        }
    }

    nowPlaying(message) {
        const serverQueue = this.queue.get(message.guild.id);
        if (!serverQueue || !serverQueue.songs.length) {
            return message.channel.send('‚ùå No hay m√∫sica reproduci√©ndose!');
        }

        const song = serverQueue.songs[0];
        const embed = {
            color: 0x00ff00,
            title: 'üéµ Reproduciendo Ahora',
            description: `**${song.title}**`,
            thumbnail: { url: song.thumbnail || '' },
            fields: [
                { name: 'üì∫ Canal', value: song.channel, inline: true },
                { name: '‚è±Ô∏è Duraci√≥n', value: this.formatDuration(song.duration), inline: true },
                { name: 'üìã En Cola', value: `${serverQueue.songs.length - 1} canci√≥n(es)`, inline: true }
            ],
            timestamp: new Date(),
        };

        return message.channel.send({ embeds: [embed] });
    }
}

module.exports = MusicHandler;